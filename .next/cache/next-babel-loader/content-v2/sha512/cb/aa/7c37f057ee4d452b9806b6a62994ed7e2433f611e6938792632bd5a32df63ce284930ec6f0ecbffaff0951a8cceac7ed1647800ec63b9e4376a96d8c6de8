{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useCallback } from 'react';\nimport { CommerceError } from '@commerce/utils/errors';\nimport useCustomer from '../customer/use-customer';\nimport createCustomerAccessTokenMutation from '../utils/mutations/customer-access-token-create';\nimport useLogin from '@commerce/auth/use-login';\nimport { setCustomerToken, throwUserErrors } from '../utils';\nexport default useLogin;\n\nconst getErrorMessage = ({\n  code,\n  message\n}) => {\n  switch (code) {\n    case 'UNIDENTIFIED_CUSTOMER':\n      message = 'Cannot find an account that matches the provided credentials';\n      break;\n  }\n\n  return message;\n};\n\nexport const handler = {\n  fetchOptions: {\n    query: createCustomerAccessTokenMutation\n  },\n\n  async fetcher({\n    input: {\n      email,\n      password\n    },\n    options,\n    fetch\n  }) {\n    if (!(email && password)) {\n      throw new CommerceError({\n        message: 'A first name, last name, email and password are required to login'\n      });\n    }\n\n    const {\n      customerAccessTokenCreate\n    } = await fetch(_objectSpread(_objectSpread({}, options), {}, {\n      variables: {\n        input: {\n          email,\n          password\n        }\n      }\n    }));\n    throwUserErrors(customerAccessTokenCreate === null || customerAccessTokenCreate === void 0 ? void 0 : customerAccessTokenCreate.customerUserErrors);\n    const customerAccessToken = customerAccessTokenCreate === null || customerAccessTokenCreate === void 0 ? void 0 : customerAccessTokenCreate.customerAccessToken;\n    const accessToken = customerAccessToken === null || customerAccessToken === void 0 ? void 0 : customerAccessToken.accessToken;\n\n    if (accessToken) {\n      setCustomerToken(accessToken);\n    }\n\n    return null;\n  },\n\n  useHook: ({\n    fetch\n  }) => () => {\n    const {\n      revalidate\n    } = useCustomer();\n    return useCallback(async function login(input) {\n      const data = await fetch({\n        input\n      });\n      await revalidate();\n      return data;\n    }, [fetch, revalidate]);\n  }\n};","map":{"version":3,"sources":["/Users/thejmdw/workspace/websites/next-commerce-test/framework/shopify/auth/use-login.tsx"],"names":["useCallback","CommerceError","useCustomer","createCustomerAccessTokenMutation","useLogin","setCustomerToken","throwUserErrors","getErrorMessage","code","message","handler","fetchOptions","query","fetcher","input","email","password","options","fetch","customerAccessTokenCreate","variables","customerUserErrors","customerAccessToken","accessToken","useHook","revalidate","login","data"],"mappings":";;;;;;AAAA,SAASA,WAAT,QAA4B,OAA5B;AAEA,SAASC,aAAT,QAA+C,wBAA/C;AACA,OAAOC,WAAP,MAAwB,0BAAxB;AACA,OAAOC,iCAAP,MAA8C,iDAA9C;AAOA,OAAOC,QAAP,MAAmC,0BAAnC;AACA,SAASC,gBAAT,EAA2BC,eAA3B,QAAkD,UAAlD;AAEA,eAAeF,QAAf;;AAEA,MAAMG,eAAe,GAAG,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAA0C;AAChE,UAAQD,IAAR;AACE,SAAK,uBAAL;AACEC,MAAAA,OAAO,GAAG,8DAAV;AACA;AAHJ;;AAKA,SAAOA,OAAP;AACD,CAPD;;AASA,OAAO,MAAMC,OAA+D,GAAG;AAC7EC,EAAAA,YAAY,EAAE;AACZC,IAAAA,KAAK,EAAET;AADK,GAD+D;;AAI7E,QAAMU,OAAN,CAAc;AAAEC,IAAAA,KAAK,EAAE;AAAEC,MAAAA,KAAF;AAASC,MAAAA;AAAT,KAAT;AAA8BC,IAAAA,OAA9B;AAAuCC,IAAAA;AAAvC,GAAd,EAA8D;AAC5D,QAAI,EAAEH,KAAK,IAAIC,QAAX,CAAJ,EAA0B;AACxB,YAAM,IAAIf,aAAJ,CAAkB;AACtBQ,QAAAA,OAAO,EACL;AAFoB,OAAlB,CAAN;AAID;;AAED,UAAM;AAAEU,MAAAA;AAAF,QAAgC,MAAMD,KAAK,iCAI5CD,OAJ4C;AAK/CG,MAAAA,SAAS,EAAE;AACTN,QAAAA,KAAK,EAAE;AAAEC,UAAAA,KAAF;AAASC,UAAAA;AAAT;AADE;AALoC,OAAjD;AAUAV,IAAAA,eAAe,CAACa,yBAAD,aAACA,yBAAD,uBAACA,yBAAyB,CAAEE,kBAA5B,CAAf;AAEA,UAAMC,mBAAmB,GAAGH,yBAAH,aAAGA,yBAAH,uBAAGA,yBAAyB,CAAEG,mBAAvD;AACA,UAAMC,WAAW,GAAGD,mBAAH,aAAGA,mBAAH,uBAAGA,mBAAmB,CAAEC,WAAzC;;AAEA,QAAIA,WAAJ,EAAiB;AACflB,MAAAA,gBAAgB,CAACkB,WAAD,CAAhB;AACD;;AAED,WAAO,IAAP;AACD,GAhC4E;;AAiC7EC,EAAAA,OAAO,EAAE,CAAC;AAAEN,IAAAA;AAAF,GAAD,KAAe,MAAM;AAC5B,UAAM;AAAEO,MAAAA;AAAF,QAAiBvB,WAAW,EAAlC;AAEA,WAAOF,WAAW,CAChB,eAAe0B,KAAf,CAAqBZ,KAArB,EAA4B;AAC1B,YAAMa,IAAI,GAAG,MAAMT,KAAK,CAAC;AAAEJ,QAAAA;AAAF,OAAD,CAAxB;AACA,YAAMW,UAAU,EAAhB;AACA,aAAOE,IAAP;AACD,KALe,EAMhB,CAACT,KAAD,EAAQO,UAAR,CANgB,CAAlB;AAQD;AA5C4E,CAAxE","sourcesContent":["import { useCallback } from 'react'\nimport type { MutationHook } from '@commerce/utils/types'\nimport { CommerceError, ValidationError } from '@commerce/utils/errors'\nimport useCustomer from '../customer/use-customer'\nimport createCustomerAccessTokenMutation from '../utils/mutations/customer-access-token-create'\nimport {\n  CustomerAccessTokenCreateInput,\n  CustomerUserError,\n  Mutation,\n  MutationCheckoutCreateArgs,\n} from '../schema'\nimport useLogin, { UseLogin } from '@commerce/auth/use-login'\nimport { setCustomerToken, throwUserErrors } from '../utils'\n\nexport default useLogin as UseLogin<typeof handler>\n\nconst getErrorMessage = ({ code, message }: CustomerUserError) => {\n  switch (code) {\n    case 'UNIDENTIFIED_CUSTOMER':\n      message = 'Cannot find an account that matches the provided credentials'\n      break\n  }\n  return message\n}\n\nexport const handler: MutationHook<null, {}, CustomerAccessTokenCreateInput> = {\n  fetchOptions: {\n    query: createCustomerAccessTokenMutation,\n  },\n  async fetcher({ input: { email, password }, options, fetch }) {\n    if (!(email && password)) {\n      throw new CommerceError({\n        message:\n          'A first name, last name, email and password are required to login',\n      })\n    }\n\n    const { customerAccessTokenCreate } = await fetch<\n      Mutation,\n      MutationCheckoutCreateArgs\n    >({\n      ...options,\n      variables: {\n        input: { email, password },\n      },\n    })\n\n    throwUserErrors(customerAccessTokenCreate?.customerUserErrors)\n\n    const customerAccessToken = customerAccessTokenCreate?.customerAccessToken\n    const accessToken = customerAccessToken?.accessToken\n\n    if (accessToken) {\n      setCustomerToken(accessToken)\n    }\n\n    return null\n  },\n  useHook: ({ fetch }) => () => {\n    const { revalidate } = useCustomer()\n\n    return useCallback(\n      async function login(input) {\n        const data = await fetch({ input })\n        await revalidate()\n        return data\n      },\n      [fetch, revalidate]\n    )\n  },\n}\n"]},"metadata":{},"sourceType":"module"}