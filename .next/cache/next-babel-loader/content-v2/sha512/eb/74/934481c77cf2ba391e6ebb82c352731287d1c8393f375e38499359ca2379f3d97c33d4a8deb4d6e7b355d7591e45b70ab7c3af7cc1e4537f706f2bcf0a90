{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useCallback } from 'react';\nimport debounce from 'lodash.debounce';\nimport { ValidationError } from '@commerce/utils/errors';\nimport useUpdateItem from '@commerce/cart/use-update-item';\nimport useCart from './use-cart';\nimport { handler as removeItemHandler } from './use-remove-item';\nimport { checkoutToCart } from '../utils';\nimport { getCheckoutId, checkoutLineItemUpdateMutation } from '../utils';\nexport default useUpdateItem;\nexport const handler = {\n  fetchOptions: {\n    query: checkoutLineItemUpdateMutation\n  },\n\n  async fetcher({\n    input: {\n      itemId,\n      item\n    },\n    options,\n    fetch\n  }) {\n    if (Number.isInteger(item.quantity)) {\n      // Also allow the update hook to remove an item if the quantity is lower than 1\n      if (item.quantity < 1) {\n        return removeItemHandler.fetcher({\n          options: removeItemHandler.fetchOptions,\n          input: {\n            itemId\n          },\n          fetch\n        });\n      }\n    } else if (item.quantity) {\n      throw new ValidationError({\n        message: 'The item quantity has to be a valid integer'\n      });\n    }\n\n    const {\n      checkoutLineItemsUpdate\n    } = await fetch(_objectSpread(_objectSpread({}, options), {}, {\n      variables: {\n        checkoutId: getCheckoutId(),\n        lineItems: [{\n          id: itemId,\n          quantity: item.quantity\n        }]\n      }\n    }));\n    return checkoutToCart(checkoutLineItemsUpdate);\n  },\n\n  useHook: ({\n    fetch\n  }) => (ctx = {}) => {\n    var _ctx$wait;\n\n    const {\n      item\n    } = ctx;\n    const {\n      mutate\n    } = useCart();\n    return useCallback(debounce(async input => {\n      var _input$id, _input$productId, _input$productId2;\n\n      const itemId = (_input$id = input.id) !== null && _input$id !== void 0 ? _input$id : item === null || item === void 0 ? void 0 : item.id;\n      const productId = (_input$productId = input.productId) !== null && _input$productId !== void 0 ? _input$productId : item === null || item === void 0 ? void 0 : item.productId;\n      const variantId = (_input$productId2 = input.productId) !== null && _input$productId2 !== void 0 ? _input$productId2 : item === null || item === void 0 ? void 0 : item.variantId;\n\n      if (!itemId || !productId || !variantId) {\n        throw new ValidationError({\n          message: 'Invalid input used for this operation'\n        });\n      }\n\n      const data = await fetch({\n        input: {\n          item: {\n            productId,\n            variantId,\n            quantity: input.quantity\n          },\n          itemId\n        }\n      });\n      await mutate(data, false);\n      return data;\n    }, (_ctx$wait = ctx.wait) !== null && _ctx$wait !== void 0 ? _ctx$wait : 500), [fetch, mutate]);\n  }\n};","map":{"version":3,"sources":["/Users/thejmdw/workspace/websites/next-commerce-test/framework/shopify/cart/use-update-item.tsx"],"names":["useCallback","debounce","ValidationError","useUpdateItem","useCart","handler","removeItemHandler","checkoutToCart","getCheckoutId","checkoutLineItemUpdateMutation","fetchOptions","query","fetcher","input","itemId","item","options","fetch","Number","isInteger","quantity","message","checkoutLineItemsUpdate","variables","checkoutId","lineItems","id","useHook","ctx","mutate","productId","variantId","data","wait"],"mappings":";;;;;;AAAA,SAASA,WAAT,QAA4B,OAA5B;AACA,OAAOC,QAAP,MAAqB,iBAArB;AAKA,SAASC,eAAT,QAAgC,wBAAhC;AACA,OAAOC,aAAP,MAGO,gCAHP;AAKA,OAAOC,OAAP,MAAoB,YAApB;AACA,SAASC,OAAO,IAAIC,iBAApB,QAA6C,mBAA7C;AAEA,SAASC,cAAT,QAA+B,UAA/B;AACA,SAASC,aAAT,EAAwBC,8BAAxB,QAA8D,UAA9D;AAOA,eAAeN,aAAf;AAEA,OAAO,MAAME,OAAO,GAAG;AACrBK,EAAAA,YAAY,EAAE;AACZC,IAAAA,KAAK,EAAEF;AADK,GADO;;AAIrB,QAAMG,OAAN,CAAc;AACZC,IAAAA,KAAK,EAAE;AAAEC,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KADK;AAEZC,IAAAA,OAFY;AAGZC,IAAAA;AAHY,GAAd,EAI2C;AACzC,QAAIC,MAAM,CAACC,SAAP,CAAiBJ,IAAI,CAACK,QAAtB,CAAJ,EAAqC;AACnC;AACA,UAAIL,IAAI,CAACK,QAAL,GAAiB,CAArB,EAAwB;AACtB,eAAOd,iBAAiB,CAACM,OAAlB,CAA0B;AAC/BI,UAAAA,OAAO,EAAEV,iBAAiB,CAACI,YADI;AAE/BG,UAAAA,KAAK,EAAE;AAAEC,YAAAA;AAAF,WAFwB;AAG/BG,UAAAA;AAH+B,SAA1B,CAAP;AAKD;AACF,KATD,MASO,IAAIF,IAAI,CAACK,QAAT,EAAmB;AACxB,YAAM,IAAIlB,eAAJ,CAAoB;AACxBmB,QAAAA,OAAO,EAAE;AADe,OAApB,CAAN;AAGD;;AACD,UAAM;AAAEC,MAAAA;AAAF,QAA8B,MAAML,KAAK,iCAI1CD,OAJ0C;AAK7CO,MAAAA,SAAS,EAAE;AACTC,QAAAA,UAAU,EAAEhB,aAAa,EADhB;AAETiB,QAAAA,SAAS,EAAE,CACT;AACEC,UAAAA,EAAE,EAAEZ,MADN;AAEEM,UAAAA,QAAQ,EAAEL,IAAI,CAACK;AAFjB,SADS;AAFF;AALkC,OAA/C;AAgBA,WAAOb,cAAc,CAACe,uBAAD,CAArB;AACD,GAxCoB;;AAyCrBK,EAAAA,OAAO,EAAE,CAAC;AACRV,IAAAA;AADQ,GAAD,KAEmD,CAG1DW,GAGC,GAAG,EANsD,KAOvD;AAAA;;AACH,UAAM;AAAEb,MAAAA;AAAF,QAAWa,GAAjB;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAazB,OAAO,EAA1B;AAEA,WAAOJ,WAAW,CAChBC,QAAQ,CAAC,MAAOY,KAAP,IAAqC;AAAA;;AAC5C,YAAMC,MAAM,gBAAGD,KAAK,CAACa,EAAT,iDAAeX,IAAf,aAAeA,IAAf,uBAAeA,IAAI,CAAEW,EAAjC;AACA,YAAMI,SAAS,uBAAGjB,KAAK,CAACiB,SAAT,+DAAsBf,IAAtB,aAAsBA,IAAtB,uBAAsBA,IAAI,CAAEe,SAA3C;AACA,YAAMC,SAAS,wBAAGlB,KAAK,CAACiB,SAAT,iEAAsBf,IAAtB,aAAsBA,IAAtB,uBAAsBA,IAAI,CAAEgB,SAA3C;;AACA,UAAI,CAACjB,MAAD,IAAW,CAACgB,SAAZ,IAAyB,CAACC,SAA9B,EAAyC;AACvC,cAAM,IAAI7B,eAAJ,CAAoB;AACxBmB,UAAAA,OAAO,EAAE;AADe,SAApB,CAAN;AAGD;;AAED,YAAMW,IAAI,GAAG,MAAMf,KAAK,CAAC;AACvBJ,QAAAA,KAAK,EAAE;AACLE,UAAAA,IAAI,EAAE;AACJe,YAAAA,SADI;AAEJC,YAAAA,SAFI;AAGJX,YAAAA,QAAQ,EAAEP,KAAK,CAACO;AAHZ,WADD;AAMLN,UAAAA;AANK;AADgB,OAAD,CAAxB;AAUA,YAAMe,MAAM,CAACG,IAAD,EAAO,KAAP,CAAZ;AACA,aAAOA,IAAP;AACD,KAtBO,eAsBLJ,GAAG,CAACK,IAtBC,iDAsBO,GAtBP,CADQ,EAwBhB,CAAChB,KAAD,EAAQY,MAAR,CAxBgB,CAAlB;AA0BD;AAhFoB,CAAhB","sourcesContent":["import { useCallback } from 'react'\nimport debounce from 'lodash.debounce'\nimport type {\n  HookFetcherContext,\n  MutationHookContext,\n} from '@commerce/utils/types'\nimport { ValidationError } from '@commerce/utils/errors'\nimport useUpdateItem, {\n  UpdateItemInput as UpdateItemInputBase,\n  UseUpdateItem,\n} from '@commerce/cart/use-update-item'\n\nimport useCart from './use-cart'\nimport { handler as removeItemHandler } from './use-remove-item'\nimport type { Cart, LineItem, UpdateCartItemBody } from '../types'\nimport { checkoutToCart } from '../utils'\nimport { getCheckoutId, checkoutLineItemUpdateMutation } from '../utils'\nimport { Mutation, MutationCheckoutLineItemsUpdateArgs } from '../schema'\n\nexport type UpdateItemInput<T = any> = T extends LineItem\n  ? Partial<UpdateItemInputBase<LineItem>>\n  : UpdateItemInputBase<LineItem>\n\nexport default useUpdateItem as UseUpdateItem<typeof handler>\n\nexport const handler = {\n  fetchOptions: {\n    query: checkoutLineItemUpdateMutation,\n  },\n  async fetcher({\n    input: { itemId, item },\n    options,\n    fetch,\n  }: HookFetcherContext<UpdateCartItemBody>) {\n    if (Number.isInteger(item.quantity)) {\n      // Also allow the update hook to remove an item if the quantity is lower than 1\n      if (item.quantity! < 1) {\n        return removeItemHandler.fetcher({\n          options: removeItemHandler.fetchOptions,\n          input: { itemId },\n          fetch,\n        })\n      }\n    } else if (item.quantity) {\n      throw new ValidationError({\n        message: 'The item quantity has to be a valid integer',\n      })\n    }\n    const { checkoutLineItemsUpdate } = await fetch<\n      Mutation,\n      MutationCheckoutLineItemsUpdateArgs\n    >({\n      ...options,\n      variables: {\n        checkoutId: getCheckoutId(),\n        lineItems: [\n          {\n            id: itemId,\n            quantity: item.quantity,\n          },\n        ],\n      },\n    })\n\n    return checkoutToCart(checkoutLineItemsUpdate)\n  },\n  useHook: ({\n    fetch,\n  }: MutationHookContext<Cart | null, UpdateCartItemBody>) => <\n    T extends LineItem | undefined = undefined\n  >(\n    ctx: {\n      item?: T\n      wait?: number\n    } = {}\n  ) => {\n    const { item } = ctx\n    const { mutate } = useCart() as any\n\n    return useCallback(\n      debounce(async (input: UpdateItemInput<T>) => {\n        const itemId = input.id ?? item?.id\n        const productId = input.productId ?? item?.productId\n        const variantId = input.productId ?? item?.variantId\n        if (!itemId || !productId || !variantId) {\n          throw new ValidationError({\n            message: 'Invalid input used for this operation',\n          })\n        }\n\n        const data = await fetch({\n          input: {\n            item: {\n              productId,\n              variantId,\n              quantity: input.quantity,\n            },\n            itemId,\n          },\n        })\n        await mutate(data, false)\n        return data\n      }, ctx.wait ?? 500),\n      [fetch, mutate]\n    )\n  },\n}\n"]},"metadata":{},"sourceType":"module"}