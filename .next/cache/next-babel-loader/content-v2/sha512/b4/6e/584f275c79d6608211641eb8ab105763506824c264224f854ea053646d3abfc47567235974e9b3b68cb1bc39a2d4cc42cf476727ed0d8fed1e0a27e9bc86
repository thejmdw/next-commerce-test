{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport useSearch from '@commerce/product/use-search';\nimport { getAllProductsQuery, getCollectionProductsQuery, getSearchVariables, normalizeProduct } from '../utils';\nexport default useSearch;\nexport const handler = {\n  fetchOptions: {\n    query: getAllProductsQuery\n  },\n\n  async fetcher({\n    input,\n    options,\n    fetch\n  }) {\n    const {\n      categoryId,\n      brandId\n    } = input;\n    const data = await fetch({\n      query: categoryId ? getCollectionProductsQuery : options.query,\n      method: options === null || options === void 0 ? void 0 : options.method,\n      variables: getSearchVariables(input)\n    });\n    let edges;\n\n    if (categoryId) {\n      var _data$node$products$e, _data$node, _data$node$products;\n\n      edges = (_data$node$products$e = (_data$node = data.node) === null || _data$node === void 0 ? void 0 : (_data$node$products = _data$node.products) === null || _data$node$products === void 0 ? void 0 : _data$node$products.edges) !== null && _data$node$products$e !== void 0 ? _data$node$products$e : [];\n\n      if (brandId) {\n        edges = edges.filter(({\n          node: {\n            vendor\n          }\n        }) => vendor.replace(/\\s+/g, '-').toLowerCase() === brandId);\n      }\n    } else {\n      var _data$products$edges, _data$products;\n\n      edges = (_data$products$edges = (_data$products = data.products) === null || _data$products === void 0 ? void 0 : _data$products.edges) !== null && _data$products$edges !== void 0 ? _data$products$edges : [];\n    }\n\n    return {\n      products: edges.map(({\n        node\n      }) => normalizeProduct(node)),\n      found: !!edges.length\n    };\n  },\n\n  useHook: ({\n    useData\n  }) => (input = {}) => {\n    return useData({\n      input: [['search', input.search], ['categoryId', input.categoryId], ['brandId', input.brandId], ['sort', input.sort]],\n      swrOptions: _objectSpread({\n        revalidateOnFocus: false\n      }, input.swrOptions)\n    });\n  }\n};","map":{"version":3,"sources":["/Users/thejmdw/workspace/websites/next-commerce-test/framework/shopify/product/use-search.tsx"],"names":["useSearch","getAllProductsQuery","getCollectionProductsQuery","getSearchVariables","normalizeProduct","handler","fetchOptions","query","fetcher","input","options","fetch","categoryId","brandId","data","method","variables","edges","node","products","filter","vendor","replace","toLowerCase","map","found","length","useHook","useData","search","sort","swrOptions","revalidateOnFocus"],"mappings":";;;;;;AACA,OAAOA,SAAP,MAAqC,8BAArC;AAGA,SACEC,mBADF,EAEEC,0BAFF,EAGEC,kBAHF,EAIEC,gBAJF,QAKO,UALP;AASA,eAAeJ,SAAf;AAcA,OAAO,MAAMK,OAIZ,GAAG;AACFC,EAAAA,YAAY,EAAE;AACZC,IAAAA,KAAK,EAAEN;AADK,GADZ;;AAIF,QAAMO,OAAN,CAAc;AAAEC,IAAAA,KAAF;AAASC,IAAAA,OAAT;AAAkBC,IAAAA;AAAlB,GAAd,EAAyC;AACvC,UAAM;AAAEC,MAAAA,UAAF;AAAcC,MAAAA;AAAd,QAA0BJ,KAAhC;AAEA,UAAMK,IAAI,GAAG,MAAMH,KAAK,CAAC;AACvBJ,MAAAA,KAAK,EAAEK,UAAU,GAAGV,0BAAH,GAAgCQ,OAAO,CAACH,KADlC;AAEvBQ,MAAAA,MAAM,EAAEL,OAAF,aAAEA,OAAF,uBAAEA,OAAO,CAAEK,MAFM;AAGvBC,MAAAA,SAAS,EAAEb,kBAAkB,CAACM,KAAD;AAHN,KAAD,CAAxB;AAMA,QAAIQ,KAAJ;;AAEA,QAAIL,UAAJ,EAAgB;AAAA;;AACdK,MAAAA,KAAK,0CAAGH,IAAI,CAACI,IAAR,sEAAG,WAAWC,QAAd,wDAAG,oBAAqBF,KAAxB,yEAAiC,EAAtC;;AACA,UAAIJ,OAAJ,EAAa;AACXI,QAAAA,KAAK,GAAGA,KAAK,CAACG,MAAN,CACN,CAAC;AAAEF,UAAAA,IAAI,EAAE;AAAEG,YAAAA;AAAF;AAAR,SAAD,KACEA,MAAM,CAACC,OAAP,CAAe,MAAf,EAAuB,GAAvB,EAA4BC,WAA5B,OAA8CV,OAF1C,CAAR;AAID;AACF,KARD,MAQO;AAAA;;AACLI,MAAAA,KAAK,6CAAGH,IAAI,CAACK,QAAR,mDAAG,eAAeF,KAAlB,uEAA2B,EAAhC;AACD;;AAED,WAAO;AACLE,MAAAA,QAAQ,EAAEF,KAAK,CAACO,GAAN,CAAU,CAAC;AAAEN,QAAAA;AAAF,OAAD,KAA2Bd,gBAAgB,CAACc,IAAD,CAArD,CADL;AAELO,MAAAA,KAAK,EAAE,CAAC,CAACR,KAAK,CAACS;AAFV,KAAP;AAID,GA/BC;;AAgCFC,EAAAA,OAAO,EAAE,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAiB,CAACnB,KAAK,GAAG,EAAT,KAAgB;AACxC,WAAOmB,OAAO,CAAC;AACbnB,MAAAA,KAAK,EAAE,CACL,CAAC,QAAD,EAAWA,KAAK,CAACoB,MAAjB,CADK,EAEL,CAAC,YAAD,EAAepB,KAAK,CAACG,UAArB,CAFK,EAGL,CAAC,SAAD,EAAYH,KAAK,CAACI,OAAlB,CAHK,EAIL,CAAC,MAAD,EAASJ,KAAK,CAACqB,IAAf,CAJK,CADM;AAObC,MAAAA,UAAU;AACRC,QAAAA,iBAAiB,EAAE;AADX,SAELvB,KAAK,CAACsB,UAFD;AAPG,KAAD,CAAd;AAYD;AA7CC,CAJG","sourcesContent":["import { SWRHook } from '@commerce/utils/types'\nimport useSearch, { UseSearch } from '@commerce/product/use-search'\n\nimport { ProductEdge } from '../schema'\nimport {\n  getAllProductsQuery,\n  getCollectionProductsQuery,\n  getSearchVariables,\n  normalizeProduct,\n} from '../utils'\n\nimport { Product } from '@commerce/types'\n\nexport default useSearch as UseSearch<typeof handler>\n\nexport type SearchProductsInput = {\n  search?: string\n  categoryId?: string\n  brandId?: string\n  sort?: string\n}\n\nexport type SearchProductsData = {\n  products: Product[]\n  found: boolean\n}\n\nexport const handler: SWRHook<\n  SearchProductsData,\n  SearchProductsInput,\n  SearchProductsInput\n> = {\n  fetchOptions: {\n    query: getAllProductsQuery,\n  },\n  async fetcher({ input, options, fetch }) {\n    const { categoryId, brandId } = input\n\n    const data = await fetch({\n      query: categoryId ? getCollectionProductsQuery : options.query,\n      method: options?.method,\n      variables: getSearchVariables(input),\n    })\n\n    let edges\n\n    if (categoryId) {\n      edges = data.node?.products?.edges ?? []\n      if (brandId) {\n        edges = edges.filter(\n          ({ node: { vendor } }: ProductEdge) =>\n            vendor.replace(/\\s+/g, '-').toLowerCase() === brandId\n        )\n      }\n    } else {\n      edges = data.products?.edges ?? []\n    }\n\n    return {\n      products: edges.map(({ node }: ProductEdge) => normalizeProduct(node)),\n      found: !!edges.length,\n    }\n  },\n  useHook: ({ useData }) => (input = {}) => {\n    return useData({\n      input: [\n        ['search', input.search],\n        ['categoryId', input.categoryId],\n        ['brandId', input.brandId],\n        ['sort', input.sort],\n      ],\n      swrOptions: {\n        revalidateOnFocus: false,\n        ...input.swrOptions,\n      },\n    })\n  },\n}\n"]},"metadata":{},"sourceType":"module"}